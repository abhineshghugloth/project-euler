# Pentagonal numbers are generated by the formula, Pn=n(3n1)/2. The first ten pentagonal numbers are:
# 
# 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
# 
# It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 22 = 48, is not pentagonal.
# 
# Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference is pentagonal and D = |Pk Pj| is minimised; what is the value of D?

#equivalent: find pentagonal a<b such that a+b and a+2b are both pentagonal. Return a

#the difference between any two consecutive is an arithmetic sequence with difference 3 and initial value 4

#found one pair: 1560090 and 5482660. However, it is not accepted as a valid solution. This gives a bound

#1560090 is pentagonal no. 1020
require 'common'

class Integer
	def pentagonal?
		n=((1+(1+24*self).sqrt) / 6).to_i
		self == (n*(3*n-1) / 2)
	end
	def pentagonal
		(self*(3*self - 1) / 2)
	end
	def difference?
		a0=4
		while a0<self
			sol=solve_equation(3,2*a0-3,-2*self)
			n=sol.to_i
			return [a0,n] if self == sum(a0,3,n)
			a0 += 3
		end
	end
	def is_ok?
		puts self
		a0=4
		while a0<self
			sol=solve_equation(3,2*a0-3,-2*self)
			n=sol.to_i
			if self == sum(a0,3,n)
				sol=solve_equation(3,2*a0-3,-4*self)
				n=sol.to_i
				return true if 2*self == sum(a0,3,n) 
			end
			a0 += 3
		end
		return false
	end
end

def doubles_for(a0,max)
	n=1
	summand = sum(a0,3,n)
	found={}
	results = []
	while summand<max
		found[summand] = true
		results << summand / 2 if summand % 2 == 0 and found[summand / 2] == true
		n += 1
		summand = sum(a0,3,n)
	end
	return results
end

def solve_equation(a,b,c)
	(-b + (b**2 - 4*a*c).sqrt) / (2*a)
end

def sum(a0,d,n)
	n*a0+d*(n*(n-1) / 2 )
end

# puts (1..10000).find_all{|i| 4+3*i<1560090}
# puts (1..1000).collect{|x| x.pentagonal}.reject{|x| not x.is_ok?}
# puts (1..10000).collect{|x| x.pentagonal+1560090}.find_all{|y| y.pentagonal? and (y+1560090).pentagonal?}
# puts (1560090 - 4)  / 3
# (3*520030).times do |i|
# 	puts doubles_for(4+3*i,3*1560091).reject{|x| not x.pentagonal?}
# end

# 1560090 and 5482660
a=1560090
b=5482660

puts a.pentagonal?
puts b.pentagonal?
puts (a+b).pentagonal?
puts (2*a+b).pentagonal?

# 100.times do |i|
# 	puts ((1..1000).collect{|x| [sum(4+3*i,3,x),i,x]}.reject{|x| not x[0].pentagonal?}.inspect)
# end
# def possible_difference_for(t)
# 	results = []
# 	n=1
# 	while true
# 		
# 	end
# end

# 
# result = nil
# j = 0
# while result == nil
# 	j += 1
# 	puts j
# 	(1..j-1).each do |i|
# 		a=i.pentagonal
# 		b=j.pentagonal
# 		if ((a+b).pentagonal? and (a+2*b).pentagonal?)
# 			result = a
# 			break
# 		end
# 		puts "a=#{a}, b=#{b}, a+b=#{a+b} and a+2b=#{a+2*b}" if ((a+b).pentagonal? or (a+2*b).pentagonal?)
# 	end
# end
# 
# puts result
# 
# def all_pairs
# 	k=2
# 	while true
# 		(1..k-1).each {|i| yield(i,k-i)}
# 		k += 1
# 	end
# end
# 
# def pentagonals(upto)
# 	(1..upto).collect{|n| (n*(3*n-1)) / 2}
# end
# 
# 
# current_d=nil
# 
# all_pairs do |j,k|
# 	next if j <= k
# # 	puts "#{j},#{k}"
# 	sum = j.pentagonal + k.pentagonal
# 	difference = j.pentagonal - k.pentagonal
# 	current_d = difference if difference.pentagonal? and sum.pentagonal?
# 	min_difference = (j+1).pentagonal - j.pentagonal
# 
# # 	puts j.pentagonal
# # 	puts k.pentagonal
# 	break if current_d != nil and current_d < min_difference
# end
# 
# puts current_d
