# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
# Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
# Square 	  	P4,n=n2 	  	1, 4, 9, 16, 25, ...
# Pentagonal 	  	P5,n=n(3n-1)/2 	  	1, 5, 12, 22, 35, ...
# Hexagonal 	  	P6,n=n(2n-1) 	  	1, 6, 15, 28, 45, ...
# Heptagonal 	  	P7,n=n(5n-3)/2 	  	1, 7, 18, 34, 55, ...
# Octagonal 	  	P8,n=n(3n-2) 	  	1, 8, 21, 40, 65, ...
# 
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
# 
#    1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
#    2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
#    3. This is the only set of 4-digit numbers with this property.
# 
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
require 'common'

def triangle_nums(max)
	(1..max).collect{|n| n*(n+1) / 2}.reject{|x| x>max}
end

def square_nums(max)
	(1..max).collect{|n| n**2}.reject{|x| x>max}
end

def pentagonal_nums(max)
	(1..max).collect{|n| n*(3*n-1) / 2}.reject{|x| x>max}
end

def hexagonal_nums(max)
	(1..max).collect{|n| n*(2*n-1)}.reject{|x| x>max}
end

def heptagonal_nums(max)
	(1..max).collect{|n| n*(5*n-3) / 2}.reject{|x| x>max}
end

def octagonal_nums(max)
	(1..max).collect{|n| n*(3*n-2)}.reject{|x| x>max}
end

def cycle_pair(x,y)
	x.to_s[2..3]==y.to_s[0..1]
end

def find_cycle(nums)
	def cycle_recurse(nums)
#  		puts "nums" + nums.inspect
		return [] if nums.first.length == 0
		return nums if nums.length == 1
		results = []
		nums.first.each do |x|
			new_nums = nums.dup[1..-1]
			new_nums[0] = new_nums.first.reject{|y| not cycle_pair(x,y)}
#  			puts "new nums for #{x}: " + new_nums.inspect
			results += cycle_recurse(new_nums).collect{|arr| arr.unshift(x)}
#  			puts "results" + results.inspect
		end
		return results
	end
	results = []
# 	nums.all_permutations.each do |p|
# 		puts p.inspect
# 		results << cycle_recurse([nums.first] + p).reject{|c| not cycle_pair(c.last,c.first)}
# 	end

	nums[1..-1].all_permutations.each do |p|
		results << cycle_recurse([nums.first] + p).reject{|c| not cycle_pair(c.last,c.first)}
	end
	return results
end

max = 9999
nums = []
nums << 
	triangle_nums(max).reject{|x| x<1000} << 
	square_nums(max).reject{|x| x<1000} << 
	pentagonal_nums(max).reject{|x| x<1000} <<
	hexagonal_nums(max).reject{|x| x<1000} <<
	heptagonal_nums(max).reject{|x| x<1000} <<
	octagonal_nums(max).reject{|x| x<1000}

# puts nums.inspect
# nums = [(1000..2000).to_a, (1000..2000).to_a, (1000..2000).to_a]
# nums = [[1234, 1288,5434],[3477,3456, 8856,8877],[5678,7755]]
# puts find_cycle(nums).inspect
puts [8256, 5625, 2512, 1281, 8128, 2882].sum